__scope = function()
    // AptClient
    //   add_repo
    //   check_upgrade
    //   del_repo
    //   install
    //   search
    //   show
    //   update
    // Blockchain
    //   amount_mined
    //   coin_price
    //   create_wallet
    //   delete_coin
    //   get_coin
    //   login_wallet
    //   show_history
    // Class
    // Coin
    //   create_subwallet
    //   get_address
    //   get_cycle_mining
    //   get_mined_coins
    //   get_reward
    //   get_subwallet
    //   get_subwallets
    //   reset_password
    //   set_address
    //   set_cycle_mining
    //   set_reward
    //   transaction
    // Computer
    //   File
    //   active_net_card
    //   change_password
    //   close_program
    //   connect_ethernet
    //   connect_wifi
    //   create_folder
    //   create_group
    //   create_user
    //   delete_group
    //   delete_user
    //   get_name
    //   get_ports
    //   groups
    //   is_network_active
    //   local_ip
    //   network_devices
    //   network_gateway
    //   public_ip
    //   show_procs
    //   touch
    //   wifi_networks
    // Crypto
    //   aircrack
    //   aireplay
    //   airmon
    //   decipher
    //   smtp_user_list
    // CtfEvent
    //   get_creator_name
    //   get_description
    //   get_mail_content
    //   get_template
    //   player_success

    globals.event = {}
    event.events = {}

    // Registers a function to be called when a specific event is triggered.
    // @description **Description:**
    // @description - This function allows registering one or more callback functions (`func`) to be executed when an event with the specified name (`eventName`) is emitted.
    //
    // @description **Parameters:**
    // @param {string} eventName
    // @description `eventName: string` The name of the event to which the function is to be registered.
    // @param {function} func
    // @description `func: function` The callback function to be executed when the event is emitted.
    //
    // @description **Returns:**
    // @return {void}
    // @description Does not return a value.
    //
    // @example event.on("userLogin", @loginUserFunction) // Registers `loginUserFunction` to be called when "userLogin" event is emitted
    event.on = function(eventName, func)
        if not eventName.isIn(event.events) then
            event.events.add(eventName, [@func])
        else
            l = event.events[eventName]
            l.push(@func)
            event.events[eventName] = l
        end if
    end function

    // Triggers all functions associated with a specific event.
    // @description **Description:**
    // @description - This function triggers the execution of all callback functions registered for a specific event name (`eventName`).
    // @description - If the event name is not found within the list of registered events, a warning is logged. Otherwise, it iterates through the list of functions associated with the event and executes them.
    //
    // @description **Parameters:**
    // @param {string} eventName
    // @description `eventName: string` The name of the event to be emitted.
    //
    // @description **Returns:**
    // @return {void}
    // @description Does not return a value.
    //
    // @example event.emit("userLogin") // Triggers execution of all functions registered under "userLogin" event
    event.emit = function(eventName)
        if not eventName.isIn(event.events) then
            logger.warn("event.emit", "'" + eventName + "' not registered in the event list.")
        else
            for func in event.events[eventName]
                func
            end for
        end if
    end function

    // File
    //   allow_import
    //   chmod
    //   copy
    //   delete
    //   get_content
    //   get_files
    //   get_folders
    //   group
    //   has_permission
    //   is_binary
    //   is_folder
    //   move
    //   name
    //   owner
    //   parent
    //   path
    //   permissions
    //   rename
    //   set_content
    //   set_group
    //   set_owner
    //   size

    // FtpShell
    //   host_computer
    //   put
    //   start_terminal
    // Function
    // General
    //   File
    //   abs
    //   acos
    //   active_net_card
    //   active_user
    //   add_repo
    //   aircrack
    //   aireplay
    //   airmon
    //   allow_import
    //   amount_mined
    //   asin
    //   atan
    //   bitAnd
    //   bitOr
    //   bitXor
    //   bitwise
    //   bssid_name
    //   build
    //   buy_coin
    //   cancel_pending_trade
    //   ceil
    //   change_password
    //   char
    //   check_password
    //   check_upgrade
    //   chmod
    //   clear_screen
    //   close_program
    //   code
    //   coin_price
    //   command_info
    //   connect_ethernet
    //   connect_service
    //   connect_wifi
    //   copy
    //   cos
    //   create_folder
    //   create_group
    //   create_subwallet
    //   create_user
    //   create_wallet
    //   current_date
    //   current_path
    //   decipher
    //   del_repo
    //   delete
    //   delete_coin
    //   delete_group
    //   delete_mail
    //   delete_subwallet
    //   delete_user
    //   device_ports
    //   devices_lan_ip
    //   dump_lib
    //   essid_name
    //   exit
    //   fetch
    //   firewall_rules
    //   floor
    //   format_columns
    //   get_address
    //   get_balance
    //   get_balance_subwallet
    //   get_coin
    //   get_content
    //   get_creator_name
    //   get_ctf
    //   get_custom_object
    //   get_cycle_mining
    //   get_description
    //   get_files
    //   get_folders
    //   get_global_offers
    //   get_info
    //   get_lan_ip
    //   get_mail_content
    //   get_mined_coins
    //   get_name
    //   get_num_conn_gateway
    //   get_num_portforward
    //   get_num_users
    //   get_pending_trade
    //   get_pin
    //   get_ports
    //   get_reward
    //   get_router
    //   get_shell
    //   get_subwallet
    //   get_subwallets
    //   get_switch
    //   get_template
    //   get_user
    //   group
    //   groups
    //   hasIndex
    //   has_permission
    //   hash
    //   home_dir
    //   host_computer
    //   import_code
    //   include_lib
    //   indexOf
    //   indexes
    //   insert
    //   install
    //   install_service
    //   is_any_active_user
    //   is_binary
    //   is_closed
    //   is_folder
    //   is_lan_ip
    //   is_match
    //   is_network_active
    //   is_root_active_user
    //   is_valid_ip
    //   join
    //   kernel_version
    //   lan_ip
    //   lastIndexOf
    //   last_transaction
    //   launch
    //   launch_path
    //   len
    //   lib_name
    //   list_coins
    //   list_global_coins
    //   load
    //   local_ip
    //   log
    //   login_wallet
    //   lower
    //   mail_login
    //   matches
    //   md5
    //   mining
    //   move
    //   name
    //   net_use
    //   network_devices
    //   network_gateway
    //   nslookup
    //   overflow
    //   owner
    //   parent
    //   parent_path
    //   path
    //   permissions
    //   pi
    //   ping
    //   ping_port
    //   player_success
    //   pop
    //   port_info
    //   port_number
    //   print
    //   program_path
    //   public_ip
    //   public_ip_pc
    //   pull
    //   push
    //   range
    //   read
    //   remove
    //   rename
    //   replace
    //   replace_regex
    //   reset_ctf_password
    //   reset_password
    //   reset_password_coin
    //   reverse
    //   rnd
    //   round
    //   rshell_client
    //   rshell_server
    //   scan
    //   scan_address
    //   scp
    //   search
    //   sell_coin
    //   send
    //   set_address
    //   set_content
    //   set_cycle_mining
    //   set_group
    //   set_info
    //   set_owner
    //   set_reward
    //   show
    //   show_history
    //   show_nodes
    //   show_procs
    //   shuffle
    //   sign
    //   sin
    //   size
    //   slice
    //   smtp_user_list
    //   sniffer
    //   sort
    //   split
    //   sqrt
    //   start_service
    //   start_terminal
    //   stop_service
    //   str
    //   sum
    //   tan
    //   time
    //   to_int
    //   touch
    //   transaction
    //   trim
    //   typeof
    //   update
    //   upper
    //   used_ports
    //   user_bank_number
    //   user_input
    //   user_mail_address
    //   val
    //   values
    //   version
    //   wait
    //   wallet_username
    //   whois
    //   wifi_networks
    //   yield
    // List
    //   hasIndex
    //   indexOf
    //   indexes
    //   insert
    //   join
    //   len
    //   pop
    //   pull
    //   push
    //   remove
    //   replace
    //   reverse
    //   shuffle
    //   sort
    //   sum
    //   values
    
    // Logger
    globals.logger = {}

    // Logs an informational message.
    // @description **Description:**
    // @description - Logs an informational message if the logger's state is set to `debug` or `trace`. It formats the message with a timestamp, labels it as "Info", includes the source of the log in uppercase, and displays the message. The log message is colored and also appended to a log file, with tags removed for the file content.
    //
    // @description **Parameters:**
    // @param {string} source
    // @description `source: string` The source module or component that generated the log message.
    // @param {string} message
    // @description `message: string` The informational message to log.
    //
    // @description **Returns:**
    // @return {null}
    // @description Does not return a value.
    //
    // @example logger.info("main", "Info message...")
    // @example "[5.6742] Info: [MAIN] Info message..." // colors not included in this example
    logger.info = function(source, message)
        if logger.state != "normal" then
            logMsg = ("[" + time + "]").color("alien") + " " + "Info:".color("deep sky blue") + " " + ("[" + source.upper + "]").color("silver") + " " + message.color("alien")
            print logMsg
            //logger.file.append(logMsg.removeTags)
        end if
    end function

    // Logs a debug message.
    // @description **Description:**
    // @description - Logs a debug message if the logger's state is set to `debug` or `trace`. It formats the message with a timestamp, labels it as "Debug", includes the source of the log in uppercase, and displays the message. The log message is colored and also appended to a log file, with tags removed for the file content.
    //
    // @description **Parameters:**
    // @param {string} source
    // @description `source: string` The source module or component that generated the log message.
    // @param {string} message
    // @description `message: string` The debug message to log.
    //
    // @description **Returns:**
    // @return {null}
    // @description Does not return a value.
    //
    // @example logger.debug("main", "Debug message...")
    // @example "[5.6742] Debug: [MAIN] Debug message..." // colors not included in this example
    logger.debug = function(source, message)
        if logger.state != "normal" then
            logMsg = ("[" + time + "]").color("alien") + " " + "Debug:".color("deep sky blue") + " " + ("[" + source.upper + "]").color("silver") + " " + message.color("deep sky blue")
            print logMsg
            //logger.file.append(logMsg.removeTags)
        end if
    end function

    // Logs a trace message.
    // @description **Description:**
    // @description - Logs a trace message if the logger's state is set to `trace`. It formats the message with a timestamp, labels it as "Trace", includes the source of the log in uppercase, and displays the message. The log message is colored and also appended to a log file, with tags removed for the file content.
    //
    // @description **Parameters:**
    // @param {string} source
    // @description `source: string` The source module or component that generated the log message.
    // @param {string} message
    // @description `message: string` The trace message to log.
    //
    // @description **Returns:**
    // @return {null}
    // @description Does not return a value.
    //
    // @example logger.trace("main", "Trace message...")
    // @example "[5.6742] Trace: [MAIN] Trace message..." // colors not included in this example
    logger.trace = function(source, message)
        if logger.state == "trace" then
            logMsg = ("[" + time + "]").color("alien") + " " + "Trace:".color("deep sky blue") + " " + ("[" + source.upper + "]").color("silver") + " " + message.color("orchid")
            print logMsg
            //logger.file.append(logMsg.removeTags)
        end if
    end function

    // Logs a warning message.
    // @description **Description:**
    // @description - Logs a warning message if the logger's state is set to `debug` or `trace`. It formats the message with a timestamp, labels it as "Warn", includes the source of the log in uppercase, and displays the message. The log message is colored and also appended to a log file, with tags removed for the file content.
    //
    // @description **Parameters:**
    // @param {string} source
    // @description `source: string` The source module or component that generated the log message.
    // @param {string} message
    // @description `message: string` The warning message to log.
    //
    // @description **Returns:**
    // @return {null}
    // @description Does not return a value.
    //
    // @example logger.warn("main", "Warning message...")
    // @example "[5.6742] Warn: [MAIN] Warning message..." // colors not included in this example
    logger.warn = function(source, message)
        if logger.state != "normal" then
            logMsg = ("[" + time + "]").color("alien") + " " + "Warn:".color("deep sky blue") + " " + ("[" + source.upper + "]").color("silver") + " " + message.color("orange")
            print logMsg
            //logger.file.append(logMsg.removeTags)
        end if
    end function

    // Logs an error message.
    // @description **Description:**
    // @description - Logs an error message, regardless of the logger's state. It formats the message with a timestamp, labels it as "Error", includes the source of the log in uppercase, and displays the message. The log message is colored and also appended to a log file, with tags removed for the file content.
    //
    // @description **Parameters:**
    // @param {string} source
    // @description `source: string` The source module or component that generated the log message.
    // @param {string} message
    // @description `message: string` The error message to log.
    //
    // @description **Returns:**
    // @return {null}
    // @description Does not return a value.
    //
    // @example logger.error("main", "Error message...")
    // @example "[5.6742] Error: [MAIN] Error message..." // colors not included in this example
    logger.error = function(source, message)
        logMsg = ("[" + time + "]").color("alien") + " " + "Error:".color("deep sky blue") + " " + ("[" + source.upper + "]").color("silver") + " " + message.color("tomato")
        print logMsg
        //logger.file.append(logMsg.removeTags)
    end function

    // Logs a fatal error message.
    // @description **Description:**
    // @description - Logs a fatal error message, regardless of the logger's state. It formats the message with a timestamp, labels it as "Fatal", includes the source of the log in uppercase, and displays the message. The log message is colored and also appended to a log file, with tags removed for the file content.
    //
    // @description **Parameters:**
    // @param {string} source
    // @description `source: string` The source module or component that generated the log message.
    // @param {string} message
    // @description `message: string` The fatal error message to log.
    //
    // @description **Returns:**
    // @return {null}
    // @description Does not return a value.
    //
    // @example logger.fatal("main", "Fatal error message...")
    // @example "[5.6742] Fatal: [MAIN] Fatal error message..." // colors not included in this example
    logger.fatal = function(source, message)
        logMsg = ("[" + time + "]").color("alien") + " " + "Fatal:".color("deep sky blue") + " " + ("[" + source.upper + "]").color("silver") + " " + message.color("white").mark("red")
        print logMsg
        //logger.file.append(logMsg.removeTags)
    end function

    // Map
    //   hasIndex
    //   indexOf
    //   indexes
    //   len
    //   pop
    //   pull
    //   push
    //   remove
    //   replace
    //   shuffle
    //   sum
    //   values

    // Adds a key-value pair to a map.
    // @description **Description:**
    // @description - Adds a key-value pair to the map object. The key is added to the list of keys in the map, and the key-value pair is stored in the map.
    //
    // @description **Parameters:**
    // @param {string} key
    // @description `key: string` The key to add to the map.
    // @param {any} value
    // @description `value: any` The value to associate with the key in the map.
    //
    // @description **Returns:**
    // @return {map}
    // @description `map` The map object with the new key-value pair added.
    //
    // @example myMap = map.add("name", "Alice")
    // @example print myMap["name"]  // prints "Alice"
    map.add = function(key, value)
        m = self
        m.push(key)
        m[key] = value
        return m
    end function

    // MetaLib
    //   lib_name
    //   overflow
    //   version
    // MetaMail
    //   delete
    //   fetch
    //   read
    //   send
    // Metaxploit
    //   load
    //   net_use
    //   rshell_client
    //   rshell_server
    //   scan
    //   scan_address
    //   sniffer
    // NetSession
    //   dump_lib
    //   get_num_conn_gateway
    //   get_num_portforward
    //   get_num_users
    //   is_any_active_user
    //   is_root_active_user
    // Number

    // Converts a number into its octal form.
    // @description **Description:**
    // @description - Converts the number it is called on into octal form.
    //
    // @description **Parameters:**
    // @description None. The function operates on the number object it is called on (`self`).
    //
    // @description **Returns:**
    // @return {string}
    // @description `string` The octal representation of the number, prefixed with `0x`.
    //
    // @example print 123.toOct // prints "0o173" (decimal to octal conversion)
    number.toOct = function
        oct_digits = "01234567"
        oct_result = ""
        dec = self
        if dec == 0 then return "0o0"
        while dec > 0
            remainder = dec % 8
            oct_result = oct_digits[remainder] + oct_result
            dec = floor(dec / 8)
        end while
        return "0o" + oct_result.lstrip("0")
    end function

    // Converts a number into its binary form.
    // @description **Description:**
    // @description - Converts the number it is called on into binary form.
    //
    // @description **Parameters:**
    // @description None. The function operates on the number object it is called on (`self`).
    //
    // @description **Returns:**
    // @return {string}
    // @description `string` The binary representation of the number, prefixed with `0b`.
    //
    // @example print 123.toBin // prints "0b1111011" (decimal to binary conversion)
    number.toBin = function
        binary_str = ""
        dec = self
        if dec == 0 then return "0b0"
        while dec > 0
            binary_str = str(dec % 2) + binary_str
            dec = floor(dec / 2)
        end while
        return "0b" + binary_str.lstrip("0")
    end function

    // Converts a number into its hexadecimal form.
    // @description **Description:**
    // @description - Converts the number it is called on into hexadecimal form.
    //
    // @description **Parameters:**
    // @description None. The function operates on the number object it is called on (`self`).
    //
    // @description **Returns:**
    // @return {string}
    // @description `string` The hexadecimal representation of the number, prefixed with `0b`.
    //
    // @example print 123.toHex // prints "0x7B" (decimal to hexadecimal conversion)
    number.toHex = function
        hex_digits = "0123456789ABCDEF"
        hex_result = ""
        dec = self
        if dec == 0 then return "0x0"
        while dec > 0
            remainder = dec % 16
            hex_result = hex_digits[remainder] + hex_result
            dec = floor(dec / 16)
        end while
        return "0x" + hex_result.lstrip("0")
    end function

    // Port
    //   get_lan_ip
    //   is_closed
    //   port_number
    // Router
    //   bssid_name
    //   device_ports
    //   devices_lan_ip
    //   essid_name
    //   firewall_rules
    //   kernel_version
    //   local_ip
    //   ping_port
    //   port_info
    //   public_ip
    //   used_ports
    // Service
    //   install_service
    //   start_service
    //   stop_service
    //   Shell
    //   build
    //   connect_service
    //   host_computer
    //   launch
    //   ping
    //   scp
    //   start_terminal
    // String
    //   code
    //   hasIndex
    //   indexOf
    //   indexes
    //   insert
    //   is_match
    //   lastIndexOf
    //   len
    //   lower
    //   matches
    //   remove
    //   replace
    //   split
    //   to_int
    //   trim
    //   upper
    //   val
    //   values

    // Converts a string representing a number in decimal, binary, hexadecimal, or octal format into an array of bytes.
    // @description **Description:**
    // @description - First, checks if the string is in binary (`0b`), hexadecimal (`0x`), or octal (`0o`) format, or is a decimal number, and converts it to a binary string.
    // @description - For binary strings, it pads the string to a multiple of 8 bits and then splits it into an array of 8-bit bytes.
    // @description - If the input string is not in a recognized numeric format, or if conversion is attempted on a non-string input, it logs an error indicating the format error and returns `null`.
    //
    // @description **Parameters:**
    // @description None. The function operates on the string object it is called on (`self`).
    //
    // @description **Returns:**
    // @return {list|null}
    // @description `list` An array of strings, each representing an 8-bit byte in binary format (`0b` prefix). Returns `null` if the input format is unrecognized or if the input is not a string.
    //
    // @example print "0xFF".bytes         // prints ["0b11111111"]
    // @example print "123".bytes          // prints ["0b01111011"]
    // @example print "0b1010".bytes       // prints ["0b00001010"]
    // @example print "â‚¬".encodeUtf8.bytes // prints ["0b11100010", "0b10000010", "0b10101100"]
    // @example print "Hello".bytes        // prints null.
    string.bytes = function
        data = self
        array = []

        while len(data) != 0
        if data.lastIndexOf("0x") > data.lastIndexOf("0b") and data.lastIndexOf("0x") > data.lastIndexOf("0o") then
            array.push(data[data.lastIndexOf("0x"):].toBin[2:].zfill(8))
            data = data[:data.lastIndexOf("0x")]
        else if data.lastIndexOf("0b") > data.lastIndexOf("0x") and data.lastIndexOf("0b") > data.lastIndexOf("0o") then
            array.push(data[data.lastIndexOf("0b"):][2:].zfill(8))
            data = data[:data.lastIndexOf("0b")]
        else if data.lastIndexOf("0o") > data.lastIndexOf("0x") and data.lastIndexOf("0o") > data.lastIndexOf("0b") then
            array.push(data[data.lastIndexOf("0o"):].toBin[2:].zfill(8))
            data = data[:data.lastIndexOf("0o")]
        else
            logger.error("string.bytes", "FormatError: The input '" + self + "' is not in a recognized decimal, binary, hexadecimal, or octal format required for conversion to bytes.")
            return null
        end if
        end while
        array.reverse
        binary_string = array.join("")
        binary_string = binary_string.zfill(binary_string.len + (8 - binary_string.len % 8) % 8)
        bytes = []
        for i in range(0, len(binary_string)-1, 8)
            bytes.push("0b" + binary_string[i:i+8])
        end for
        return bytes
    end function

    // Encodes a single character to its UTF-8 representation.
    // @description **Description:**
    // @description - Converts a Unicode code point from UTF-16 to its UTF-8 equivalent. The conversion process depends on the range of the code point.
    // @description - The Unicode code point needs to be between 0 (`U+0000`) and 65535 (`U+FFFF`). Any number which is outside this range will cause the script to throw a runtime error.
    //
    // @description **Parameters:**
    // @description None. The function operates on the string it is called on (`self`), where each character must represent a single code point between `U+0000` and `U+FFFF`.
    //
    // @description **Returns:**
    // @return {string|null}
    // @description `string` The UTF-8 encoded hexadecimal representation of the Unicode code point. If the code point is outside the valid Unicode range, returns `null`.
    //
    // @example // For a character within U+0000 to U+007F: 
    // @example print "$".encodeUtf8   // prints "0x24"
    // @example
    // @example // For a character within U+0080 to U+07FF: 
    // @example print "Â£".encodeUtf8   // prints "0xC20xA3"
    // @example
    // @example // For a character within U+0800 to U+FFFF: 
    // @example print "â‚¬".encodeUtf8  // prints "0xE20x820xAC"
    // @example
    // @example // !!! Throws Runtime error in script !!!
    // @example // For a character within U+10000 to U+10FFFF:
    // @example print "ðŸ˜€".encodeUtf8 // prints "0xF00x9F0x980x80"
    string.encodeUtf8 = function
        encoded_bytes = []
        for data in self
            utf16_code_point = code(data)

            if utf16_code_point <= "0x7F".to_int then
                // For U+0000 to U+007F, UTF-8 uses the same value (1 byte)
                encoded_bytes.push(utf16_code_point.toHex)
            else if utf16_code_point <= "0x7FF".to_int then
                // For U+0080 to U+07FF, UTF-8 uses two bytes: 110xxxxx 10xxxxxx
                utf16_code_point = utf16_code_point.toBin[2:].zfill(11)
                encoded_bytes.push(("0b110" + utf16_code_point[:5]).toHex + ("0b10" + utf16_code_point[5:]).toHex)
            else if utf16_code_point <= "0xFFFF".to_int then
                // For U+0800 to U+FFFF, UTF-8 uses three bytes: 1110xxxx 10xxxxxx 10xxxxxx
                utf16_code_point = utf16_code_point.toBin[2:].zfill(16)
                encoded_bytes.push(("0b1110" + utf16_code_point[:4]).toHex + ("0b10" + utf16_code_point[4:10]).toHex + ("0b10" + utf16_code_point[10:]).toHex)
            else if utf16_code_point <= "0x10FFFF".to_int then // !!! Throws Runtime error in script !!!
                // For U+10000 to U+10FFFF, UTF-8 uses four bytes: 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx
                utf16_code_point = utf16_code_point.toBin[2:].zfill(21)
                encoded_bytes.push(("0b11110" + utf16_code_point[:3]).toHex + ("0b10" + utf16_code_point[3:9]).toHex + ("0b10" + utf16_code_point[9:15]).toHex + ("0b10" + utf16_code_point[15:]).toHex)
            else
                // Out of Unicode range
                logger.error("string.encodeUtf8", "FormatError: The input '" + data + "' (UTF-16: " + code(data) + ") is out of range.")
                encoded_bytes.push("0x00")
            end if
        end for
        return encoded_bytes.join("")
    end function

    // Decodes a UTF-8 encoded string.
    // @description **Description:**
    // @description - Converts a string of UTF-8 encoded bytes into its corresponding Unicode characters. The function processes 1-byte, 2-byte, and 3-byte UTF-8 sequences and appends the decoded characters to the result string.
    // @description - Since 4-byte characters are currently not supported by Greyscript, it logs an error if it encounters an unsupported 4-byte character or an invalid byte sequence.
    //
    // @description **Parameters:**
    // @description None. The function operates on the string object it is called on (`self`), which must be a string of UTF-8 encoded bytes.
    //
    // @description **Returns:**
    // @return {string}
    // @description `string` The decoded string containing Unicode characters.
    //
    // @example print "0x480x650x6C0x6C0x6F".decodeUtf8 // prints "Hello"
    // @example print "0xE20x820xAC".decodeUtf8         // prints "â‚¬"
    string.decodeUtf8 = function
        utf8_bytes = self
        decoded_chars = []
        i = 0
        
        while i < len(utf8_bytes)
            byte = utf8_bytes[i:i+4].to_int
            
            if bitAnd(byte,128) == 0 then  // 1-byte character
                decoded_chars.push(char(byte))
            else if bitAnd(byte,224) == 192 then  // 2-byte character
                byte_sequence = bitAnd(byte,31) << 6
                i = i + 4
                byte_sequence = byte_sequence | bitAnd(utf8_bytes[i:i+4].to_int,63)
                decoded_chars.push(char(byte_sequence))
            else if bitAnd(byte,240) == 224 then  // 3-byte character
                byte_sequence = bitAnd(byte,15) << 12
                i = i + 4
                byte_sequence = byte_sequence | bitAnd(utf8_bytes[i:i+4].to_int,63) << 6
                i = i + 4
                byte_sequence = byte_sequence | bitAnd(utf8_bytes[i:i+4].to_int,63)
                decoded_chars.push(char(byte_sequence))
            else if bitAnd(byte,248) == 240 then  // 4-byte character
                logger.error("string.decodeUtf8", "FormatError: The bytes '" + utf8_bytes[i:i+4*4] + "' from input '" + self + "' are a 4-byte character and are currently not supported by Greyscript.") // !!! Throws Runtime error in script !!!
                i = i + 4*4
                continue
                byte_sequence = bitAnd(byte,7) << 18
                i = i + 4
                byte_sequence = byte_sequence | bitAnd(utf8_bytes[i:i+4].to_int,63) << 12
                i = i + 4
                byte_sequence = byte_sequence | bitAnd(utf8_bytes[i:i+4].to_int,63) << 6
                i = i + 4
                byte_sequence = byte_sequence | bitAnd(utf8_bytes[i:i+4].to_int,63)
                decoded_chars.push(char(byte_sequence))
            else
                logger.error("string.decodeUtf8", "FormatError: The byte '" + utf8_bytes[i:i+4] + "' from input '" + self + "' is out of range.")
            end if
            i = i + 4
        end while
        return decoded_chars.join("")
    end function

    // Converts a string to a URL-encoded format using UTF-8 encoding for non-safe characters.
    // @description **Description:**
    // @description - Checks if each character is within the set of URL-safe characters.
    // @description - If not, the character is converted to its UTF-8 hexadecimal representation.
    //
    // @description **Parameters:**
    // @description None. The function operates on the string object it is called on (`self`).
    //
    // @description **Returns:**
    // @return {string}
    // @description `string` The URL-encoded string.
    //
    // @example print "Hello World!".encodeUrl           // prints "Hello%20World%21"
    // @example print "data=50&user=test user".encodeUrl // prints "data%3D50%26user%3Dtest%20user"
    string.encodeUrl = function
        safe_characters = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_.~"
        
        encoded_string = ""
        for c in self
            if c.isIn(safe_characters) then
                encoded_string = encoded_string + c
            else
                encoded_string = encoded_string + c.encodeUtf8.replace("0x","%")
            end if
        end for
        return encoded_string
    end function

    // Decodes a URL-encoded string back into its original format.
    // @description **Description:**
    // @description - Iterates through the URL-encoded string and decodes each percent-encoded sequence into its original characters.
    // @description - Supports decoding multi-byte UTF-8 encoded characters.
    //
    // @description **Parameters:**
    // @description None. The function operates on the string object it is called on (`self`).
    //
    // @description **Returns:**
    // @return {string}
    // @description `string` The URL-decoded string.
    //
    // @example print "Hello%20World%21".decodeUrl               // prints "Hello World!"
    // @example print "data%3D50%26user%3Dtest%20user".decodeUrl // prints "data=50&user=test user"
    string.decodeUrl = function
        decoded_text = ""
        i = 0

        encoded_text = self
        // Decode each character in the input text
        while i < len(encoded_text)
            if encoded_text[i] != "%" then
                if encoded_text[i] != char(0) then decoded_text = decoded_text + encoded_text[i]  // Add unencoded character
                i = i + 1
            else
                // Collect all parts of a multi-byte character
                bytes_sequence = ""
                while i < len(encoded_text) and encoded_text[i] == "%"
                    hex_value = encoded_text[i:i+3]
                    bytes_sequence = bytes_sequence + hex_value
                    i = i + 3
                    if i < len(encoded_text) and encoded_text[i] != "%" then break // Next character is not part of the current encoded sequence
                    if i >= len(encoded_text) then break // Reached the end of the string
                end while
                
                decoded_char = (bytes_sequence.replace("%","0x")).decodeUtf8  // Convert accumulated bytes back to character
                decoded_text = decoded_text + decoded_char
            end if
        end while
        return decoded_text
    end function

    // Encodes a string into Base64 format.
    // @description **Description:**
    // @description - Converts each character in the input string into its ASCII binary equivalent, concatenates them into a single binary string.
    // @description - Reverses the binary string temporarily to pad it on the right until its length is a multiple of 6 bits, then reverts the order for encoding.
    // @description - Splits the padded binary string into 6-bit segments and uses each segment to look up a corresponding character in a Base64 character set.
    // @description - Appends '=' to the result to make the final string length a multiple of 4.
    //
    // @description **Parameters:**
    // @description None. The function operates on the string object it is called on (`self`).
    //
    // @description **Returns:**
    // @return {string}
    // @description `string` The encoded string in Base64 format.
    //
    // @example print "hello".encodeBase64()    // prints "aGVsbG8="
    // @example print "Greyscript".encodeBase64() // prints "R3JleXNjcmlwdA=="
    string.encodeBase64 = function
        base64_chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"
        binary_string = ""
		data = self
        for byte in data
            binary_string = binary_string + code(byte).toBin[2:].zfill(8)
        end for
        binary_string = binary_string.reverse.zfill(binary_string.len + (6 - binary_string.len % 6) % 6).reverse
        encoded = ""
        for i in range(0, len(binary_string)-1, 6)
            byte_segment = ("0b" + binary_string[i:i+6]).to_int
            encoded = encoded + base64_chars[byte_segment]
        end for
        while len(encoded) % 4 != 0
            encoded = encoded + "="
        end while
        return encoded
    end function

    string.decodeBase64 = function
        base64_chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"
        binary_string = ""
        data = self
        data = data.rstrip("=")
        for byte in data
            binary_string = binary_string + base64_chars.indexOf(byte).toBin[2:].zfill(6)
        end for
        decoded = ""
        for i in range(0, len(binary_string)-8, 8)
            byte_segment = ("0b" + binary_string[i:i+8]).to_int
            decoded = decoded + char(byte_segment)
        end for
        return decoded
    end function

    // Converts the string representation of a number into its octal form.
    // @description **Description:**
    // @description - Converts binary (`0b` prefix), hexadecimal (`0x` prefix), or decimal (no prefix) representations of numbers into octal form.
    //
    // @description **Parameters:**
    // @description None. The function operates on the string object it is called on (`self`).
    //
    // @description **Returns:**
    // @return {string}
    // @description `string` The octal representation of the number, prefixed with `0x`.
    //
    // @example print "0b1010".toOct // prints "0o12" (binary to octal conversion)
    // @example print "0x123".toOct  // prints "0o443" (hexadecimal to octal conversion)
    // @example print "123".toOct    // prints "0o173" (decimal to octal conversion)
    string.toOct = function
        oct_digits = "01234567"
        oct_result = ""
        if self.startsWith("0b") then
            if self == "0b0" then return "0o0"
            binary_str = self[2:]
            binary_str = binary_str.zfill(binary_str.len + (3 - binary_str.len % 3) % 3)
            for i in range(0, binary_str.len - 1, 3)
                four_bits = binary_str[i:i+3]
                decimal_val = ("0b" + four_bits).to_int
                oct_result = oct_result + oct_digits[decimal_val]
            end for
            return "0o" + oct_result.lstrip("0")
        else if self.startsWith("0x") then
            if self == "0x0" then return "0o0"
            return self.toBin.toOct
        else
            return self.to_int.toOct
        end if
    end function

    // Converts the string representation of a number into its binary form.
    // @description **Description:**
    // @description - Converts octal (`0o` prefix), hexadecimal (`0x` prefix), or decimal (no prefix) representations of numbers into binary form.
    //
    // @description **Parameters:**
    // @description None. The function operates on the string object it is called on (`self`).
    //
    // @description **Returns:**
    // @return {string}
    // @description `string` The binary representation of the number, prefixed with `0b`.
    //
    // @example print "0o123".toBin // prints "0b1010011" (octal to binary conversion)
    // @example print "0x1A".toBin  // prints "0b11010" (hexadecimal to binary conversion)
    // @example print "10".toBin    // prints "0b1010" (decimal to binary conversion)
    string.toBin = function
        binary_mapping = {
                    "0": "0000",
                    "1": "0001",
                    "2": "0010",
                    "3": "0011",
                    "4": "0100",
                    "5": "0101",
                    "6": "0110",
                    "7": "0111",
                    "8": "1000",
                    "9": "1001",
                    "A": "1010",
                    "B": "1011",
                    "C": "1100",
                    "D": "1101",
                    "E": "1110",
                    "F": "1111",}
        binary_str = ""
        if self.startsWith("0b") then
            return self
        else if self.startsWith("0o") then
            if self == "0o0" then return "0b0"
            for digit in self[2:]
                binary_str = binary_str + binary_mapping[digit][1:]
            end for
            return "0b" + binary_str.lstrip("0")
        else if self.startsWith("0x") then
            if self == "0x0" then return "0b0"
            for digit in self[2:]
                binary_str = binary_str + binary_mapping[digit.upper]
            end for
            return "0b" + binary_str.lstrip("0")
        else
            return self.to_int.toBin
        end if
    end function

    // Converts the string representation of a number into its hexadecimal form.
    // @description **Description:**
    // @description - Converts binary (`0b` prefix), octal (`0o` prefix), or decimal (no prefix) representations of numbers into hexadecimal form.
    //
    // @description **Parameters:**
    // @description None. The function operates on the string object it is called on (`self`).
    //
    // @description **Returns:**
    // @return {string}
    // @description `string` The hexadecimal representation of the number, prefixed with `0x`.
    //
    // @example print "0b1010".toHex // prints "0xA" (binary to hexadecimal conversion)
    // @example print "0o123".toHex  // prints "0x53" (octal to hexadecimal conversion)
    // @example print "123".toHex    // prints "0x7B" (decimal to hexadecimal conversion)
    string.toHex = function
        hex_digits = "0123456789ABCDEF"
        hex_result = ""
        if self.startsWith("0b") then
            if is_match(self, "^0b0+$") then return "0x0"
            binary_str = self[2:]
            binary_str = binary_str.zfill(binary_str.len + (4 - binary_str.len % 4) % 4)
            for i in range(0, binary_str.len - 1, 4)
                four_bits = binary_str[i:i+4]
                decimal_val = ("0b" + four_bits).to_int
                hex_result = hex_result + hex_digits[decimal_val]
            end for
            return "0x" + hex_result.lstrip("0")
        else if self.startsWith("0o") then
            if is_match(self, "^0o0+$") then return "0x0"
            return self.toBin.toHex
        else
            return self.to_int.toHex
        end if
    end function

    // Converts a string representation of a number into an integer.
    // @description **Description:**
    // @description - Converts binary (`0b` prefix), octal (`0o` prefix), hexadecimal (`0x` prefix), or decimal (no prefix) string representations of numbers into their integer value. The conversion is based on the prefix of the string.
    //
    // @description **Parameters:**
    // @description None. The function operates on the string object it is called on (`self`).
    //
    // @description **Returns:**
    // @return {integer}
    // @description `integer` The integer value of the number represented by the string.
    //
    // @example print "0b1010".toInt // prints 10 (binary to decimal conversion)
    // @example print "0o123".toInt  // prints 83 (octal to decimal conversion)
    // @example print "0x1A".toInt   // prints 26 (hexadecimal to decimal conversion)
    // @example print "123".toInt    // prints 123 (direct conversion)
    string.toInt = function
        decimal = 0
        if self.startsWith("0b") then
            for i in range(self[2:].len - 1)
                decimal = decimal + to_int(self.reverse[i]) * (2 ^ i)
            end for
            return decimal
        else if self.startsWith("0o") then
            for i in range(self[2:].len - 1)
                decimal = decimal + to_int(self.reverse[i]) * (8 ^ i)
            end for
            return decimal
        else if self.startsWith("0x") then
            hex_digits = {"0":0, "1":1, "2":2, "3":3, "4":4, "5":5, "6":6, "7":7, "8":8, "9":9, "A":10, "B":11, "C":12, "D":13, "E":14, "F":15}
            for i in range(self[2:].len - 1)
                decimal = decimal + hex_digits[self.reverse[i].upper] * (16 ^ i)
            end for
            return decimal
        else
            if self.len < 10 then return to_int(self)
            data = self
            result = 0
            i = 0
            while data.len >= 10
                temp = to_int(data[-9:])
                data = data[:-9]
                result = result + (temp * (1000000000^i))
                i = i + 1
            end while
            result = result + (to_int(data) * (1000000000^i))
            return result
        end if
    end function

    // Fills the string with leading zeros to reach a specified width.
    // @description **Description:**
    // @description - This function prepends zeros to the beginning of the string until the total length of the string reaches the specified `width`. If the length of the string (`self`) is already equal to or greater than `width`, no zeros are added.
    //
    // @description **Parameters:**
    // @param {number} width
    // @description `width: number` The desired total length of the string after prepending zeros.
    //
    // @description **Returns:**
    // @return {string}
    // @description `string` The modified string with leading zeros added if necessary to reach the specified `width`.
    //
    // @example print "42".zfill(5)    // prints "00042"
    // @example print "12345".zfill(3) // prints "12345" (no change, as the string is already of equal or greater length)
    string.zfill = function(width)
        s = self
        if s.startsWith("0b") then s = s[2:]
        zeros_needed = width - s.len
        if zeros_needed > 0 then s = "0" * zeros_needed + s
        if self.startsWith("0b") then return "0b" +s
        return s
    end function

    // Reverses the order of characters in a string.
    // @description **Description:**
    // @description - This function reverses the order of characters of the string.
    //
    // @description **Parameters:**
    // @description None. The function operates on the string object it is called on (`self`).
    //
    // @description **Returns:**
    // @return {string}
    // @description `string` The original string with its characters in reverse order.
    //
    // @example print "Hello".reverse // prints "olleH"
    // @example print "12345".reverse // prints "54321"
    string.reverse = function
        s = self.values
        s.reverse
        return s.join("")
    end function

    // Checks if the string is entirely in lowercase.
    // @description **Description:**
    // @description - Determines if all alphabetic characters in the string are lowercase.
    //
    // @description **Parameters:**
    // @description None. The function operates on the string object it is called on (`self`).
    //
    // @description **Returns:**
    // @return {number}
    // @description `number` Returns `true` if the string is entirely lowercase, otherwise returns `false`.
    //
    // @example print "hello".isLower // prints true
    // @example print "Hello".isLower // prints false
    // @example print "12345".isLower // prints true, as there are no uppercase letters to compare
    string.isLower = function
        return self == self.lower
    end function

    // Checks if the string is entirely in uppercase.
    // @description **Description:**
    // @description - Determines if all alphabetic characters in the string are uppercase.
    //
    // @description **Parameters:**
    // @description None. The function operates on the string object it is called on (`self`).
    //
    // @description **Returns:**
    // @return {number}
    // @description `number` Returns `true` if the string is entirely uppercase, otherwise returns `false`.
    //
    // @example print "HELLO".isUpper // prints true
    // @example print "Hello".isUpper // prints false
    // @example print "12345".isUpper // prints true, as there are no lowercase letters to compare
    string.isUpper = function
        return self == self.upper
    end function

    // Checks if the current string is contained within the specified string.
    // @description **Description:**
    // @description - Determines if the string upon which this method is called (`self`) is found within the string passed as a parameter (`value`).
    //
    // @description **Parameters:**
    // @param {string} value
    // @description `value: string` The string within which to search for the current string (`self`).
    //
    // @description **Returns:**
    // @return {number}
    // @description `number` Returns `true` if the current string (`self`) is found within the specified string (`value`), otherwise returns `false`.
    //
    // @example print "ell".isIn("Hello")    // prints true
    // @example print "bye!".isIn("Goodbye") // prints false
    string.isIn = function(value)
        return value.indexOf(self) != null
    end function

    // Checks if the string consists only of alphanumeric characters.
    // @description **Description:**
    // @description - Iterates through each character in the string to check if all characters are alphanumeric (letters and numbers).
    //
    // @description **Parameters:**
    // @description None. The function operates on the string object it is called on (`self`).
    //
    // @description **Returns:**
    // @return {number}
    // @description `number` Returns `true` if the string is alphanumeric, otherwise `false`.
    //
    // @example print "Hello123".isalnum  // prints true
    // @example print "Hello!".isalnum    // prints false
    string.isAlnum = function
        for c in self.values
            if not c.isIn("abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789") then return false
        end for
        return true
    end function

    // Checks if the string consists only of alphabetic characters.
    // @description **Description:**
    // @description - Iterates through each character in the string to check if all characters are alphabetic (letters only).
    //
    // @description **Parameters:**
    // @description None. The function operates on the string object it is called on (`self`).
    //
    // @description **Returns:**
    // @return {number}
    // @description `number` Returns `true` if the string is alphabetic, otherwise `false`.
    //
    // @example print "Hello".isalpha    // prints true
    // @example print "Hello123".isalpha // prints false
    string.isAlpha = function
        for c in self.values
            if not c.isIn("abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ") then return false
        end for
        return true
    end function

    // Strips characters from the beginning of a string.
    // @description **Description:**
    // @description - Removes all instances of the specified characters from the beginning of the string.
    // @description - If no characters are specified, it defaults to removing whitespace characters (space, tab, newline, carriage return, form feed, and vertical tab).
    //
    // @description **Parameters:**
    // @param {string} chars
    // @description `chars: string` The string containing characters to be removed from the beginning of the calling string. If not specified, defaults to whitespace characters.
    //
    // @description **Returns:**
    // @return {string}
    // @description `string` The modified string with the specified characters removed from the beginning.
    //
    // @example print "  Hello  ".lstrip          // prints "Hello  "
    // @example print "xxHelloxx".lstrip("x")     // prints "Helloxx"
    // @example print (char(10) + "Hello").lstrip // prints "Hello"
    string.lstrip = function(chars = null)
		if chars == null then chars = " " + char(9)+char(10)+char(13)+char(12)+char(11)
        s = self
        sStart = 0
        sEnd = s.len - 1
        while sStart <= sEnd and s[sStart].isIn(chars)
            sStart = sStart + 1
        end while
        return s[sStart:]
    end function

    // Strips characters from the end of a string.
    // @description **Description:**
    // @description - Removes all instances of the specified characters from the end of the string.
    // @description - If no characters are specified, it defaults to removing whitespace characters (space, tab, newline, carriage return, form feed, and vertical tab).
    //
    // @description **Parameters:**
    // @param {string} chars
    // @description `chars: string` The string containing characters to be removed from the end of the calling string. If not specified, defaults to whitespace characters.
    //
    // @description **Returns:**
    // @return {string}
    // @description `string` The modified string with the specified characters removed from the end.
    //
    // @example print "  Hello  ".rstrip          // prints "  Hello"
    // @example print "xxHelloxx".rstrip("x")     // prints "xxHello"
    // @example print ("Hello" + char(10)).rstrip // prints "Hello"
    string.rstrip = function(chars = null)
		if chars == null then chars = " " + char(9)+char(10)+char(13)+char(12)+char(11)
        s = self
        sStart = 0
        sEnd = s.len - 1
        while sEnd >= sStart and s[sEnd].isIn(chars)
            sEnd = sEnd - 1
        end while
        return s[:sEnd+1]
    end function

    // Strips characters from both ends of a string.
    // @description **Description:**
    // @description - Removes all instances of the specified characters from the beginning and end of the string.
    // @description - If no characters are specified, it defaults to removing whitespace characters (space, tab, newline, carriage return, form feed, and vertical tab).
    //
    // @description **Parameters:**
    // @param {string} chars
    // @description `chars: string` The string containing characters to be removed from both ends of the calling string. If not specified, defaults to whitespace characters.
    //
    // @description **Returns:**
    // @return {string}
    // @description `string` The modified string with the specified characters removed from both ends.
    //
    // @example print "  Hello  ".strip                      // prints "Hello"
    // @example print "xxGreyHackxx".strip("x")              // prints "GreyHack"
    // @example print (char(10) + "World!" + char(10)).strip // prints "World!"
    string.strip = function(chars = null)
		if chars == null then chars = " " + char(9)+char(10)+char(13)+char(12)+char(11)
        s = self
        sStart = 0
        sEnd = s.len - 1
        while sStart <= sEnd and s[sStart].isIn(chars)
            sStart = sStart + 1
        end while
        while sEnd >= sStart and s[sEnd].isIn(chars)
            sEnd = sEnd - 1
        end while
        return s[sStart:sEnd+1]
    end function

    // Removes TextMesh Pro tags from a string.
    // @description **Description:**
    // @description - This function iteratively searches for and removes text enclosed within "<" and ">" characters, effectively stripping TextMesh Pro tags from the string.
    //
    // @description **Parameters:**
    // @description None. The function operates on the string object it is called on (`self`).
    //
    // @description **Returns:**
    // @return {string}
    // @description `string` The modified string with all TextMesh Pro tags removed.
    //
    // @example print "<b>Hello</b>".removeTags              // prints "Hello"
    // @example print "<color=#FF0000>Hi</color>".removeTags // prints "Hi"
    string.removeTags = function
        s = self
        while "<".isIn(s) and ">".isIn(s)
            s = s[:s.indexOf("<")] + s[s.indexOf(">")+1:]
        end while
        return s
    end function

    // Checks if a string starts with the specified substring.
    // @description **Description:**
    // @description - This function compares the beginning of the string with the provided `value` to determine if it starts with it.
    // @description - If `value` is longer than `self`, logs a warning indicating the mismatch in length and returns `false`.
    // @description - Returns `true` if the string starts with `value`, otherwise returns `false`.
    //
    // @description **Parameters:**
    // @param {string} value
    // @description `value: string` The substring to compare against the start of the string.
    //
    // @description **Returns:**
    // @return {number}
    // @description `number` Returns `true` if the string starts with the specified value, otherwise `false`.
    //
    // @example print "Hello".startsWith("He")     // prints true
    // @example print "Goodbye".startsWith("bye")  // prints false
    // @example print "World".startsWith("World!") // prints false, logs warning that "World!" is longer than "World"
    string.startsWith = function(value)
        if value.len > self.len then
            logger.warn("string.startsWith", "LengthWarning: Provided prefix '" + value + "' (length: " + str(value.len) + ") exceeds the length of the string '" + self + "' (length: " + str(self.len) + ").")
            return false
        else if self[:value.len] == value then
            return true
        else
            return false
        end if
    end function

    // Checks if a string ends with the specified substring.
    // @description **Description:**
    // @description - This function compares the ending of the string with the provided `value` to determine if it ends with it.
    // @description - If `value` is longer than `self`, logs a warning indicating the mismatch in length and returns `false`.
    // @description - Returns `true` if the string ends with `value`, otherwise returns `false`.
    //
    // @description **Parameters:**
    // @param {string} value
    // @description `value: string` The substring to compare against the end of the string.
    //
    // @description **Returns:**
    // @return {number}
    // @description `number` Returns `true` if the string ends with the specified value, otherwise `false`.
    //
    // @example print "Hello".endsWith("lo")          // prints true
    // @example print "Goodbye".endsWith("Good")      // prints false
    // @example print "World".endsWith("Hello World") // prints false, logs warning that "Hello World" is longer than "World"
    string.endsWith = function(value)
        if value.len > self.len then
            logger.warn("LengthWarning: Provided suffix '" + value + "' (length: " + str(value.len) + ") exceeds the length of the string '" + self + "' (length: " + str(self.len) + ").")
            return false
        else if self[value.len * -1:] == value then
            return true
        else
            return false
        end if
    end function

    // Applies a color to a string using both hexadecimal codes and named colors.
    // @description **Description:**
    // @description - For hex codes: Converts codes prefixed with `0x` to start with `#`.
    // @description - For named colors: Looks up and applies the corresponding hex code from `colorMap`.
    // @description - Alpha Handling: Automatically appends `FF` for full opacity if not specified in the color code.
    //
    // @description **Parameters:**
    // @param {string} value
    // @description `value: string` The color to apply. Can be a hex code in `#FF4130` or `0xFF4130` format, a named color from `colorMap`, or a hex code with alpha value like `#ff000088`.
    //
    // @description **Returns:**
    // @return {string}
    // @description `string` A colored string wrapped in `<color>` tags. If the color code is invalid, it logs an error and returns the original string.
    //
    // @example print "Hello".color("0xff0000")  // prints "Hello" in red
    // @example print "Grey".color("#00FF00")    // prints "Grey" in green
    // @example print "Hack".color("blue")       // prints "Hack" in blue 
    // @example print "World".color("#ff000088") // prints "World" in red with 88 alpha
    // @example print ":)".color("#ffFF0011")    // prints ":)" in yellow with 11 alpha
    string.color = function(value)
        if colorMap.hasIndex(value.lower) then value = colorMap[value.lower]
        if value.startsWith("0x") then value = "#" + value[2:]
        if value.startsWith("#") then
            if value.len == 7 then value = value + "ff"
            if value.len == 8 then value = value + value[-1]
            return "<color=" + value + ">" + self + "</color>"
        end if
        logger.error("string.color", "ValueError: Invalid color specification '" + value + "'. Must be a valid hex code or a named color in colorMap. Encountered in string: '" + self + "'.")
        return self
    end function

    // Applies a highlight to a string using both hexadecimal codes and named colors.
    // @description **Description:**
    // @description - For hex codes: Converts codes prefixed with `0x` to start with `#`.
    // @description - For named colors: Looks up and applies the corresponding hex code from `colorMap`.
    // @description - Alpha Handling: Automatically appends `55` for semi transparency if not specified in the color code.
    //
    // @description **Parameters:**
    // @param {string} value
    // @description `value: string` The color to apply. Can be a hex code in `#FF4130` or `0xFF4130` format, a named color from `colorMap`, or a hex code with alpha value like `#ff000088`.
    //
    // @description **Returns:**
    // @return {string}
    // @description `string` A highlighted string wrapped in `<mark>` tags. If the color code is invalid, it logs an error and returns the original string.
    //
    // @example print "Hello".mark("0xff0000")  // prints "Hello" with red hightlight
    // @example print "Grey".mark("#00FF00")    // prints "Grey" whith green hightlight
    // @example print "Hack".mark("blue")       // prints "Hack" in blue hightlight
    // @example print "World".mark("#ff000088") // prints "World" with red hightlight with 88 alpha
    // @example print ":)".mark("#ffFF0011")    // prints ":)" with yellow hightlight with 11 alpha
    string.mark = function(value)
        if colorMap.hasIndex(value.lower) then value = colorMap[value.lower]
        if value.startsWith("0x") then value = "#" + value[2:]
        if value.startsWith("#") then
            if value.len == 7 then value = value + "55"
            if value.len == 8 then value = value + value[-1]
            return "<mark=" + value + ">" + self + "</mark>"
        end if
        logger.error("string.mark", "ValueError: Invalid color specification '" + value + "'. Must be a valid hex code or a named color in colorMap. Encountered in string: '" + self + "'.")
        return self
    end function

    // SubWallet
    //   check_password
    //   delete
    //   get_balance
    //   get_info
    //   get_user
    //   last_transaction
    //   mining
    //   set_info
    //   wallet_username
    // Wallet
    //   buy_coin
    //   cancel_pending_trade
    //   get_balance
    //   get_global_offers
    //   get_pending_trade
    //   get_pin
    //   list_coins
    //   list_global_coins
    //   reset_password
    //   sell_coin
    //   show_nodes

    globals.compressLZ77 = function(text)
        i = 0
        n = text.len
        window_size = 4095
        buffer_size = 15
        table = []

        while i < n
            match_length = 0
            match_distance = 0
            if i != 0 then
                for j in range(max(0, i - window_size), i - 1)
                    k = 0
                    while k < buffer_size and i + k < n and text[j + k] == text[i + k] and k < (i - j)
                        k = k + 1
                    end while
                    if k > match_length then
                        match_length = k
                        match_distance = i - j
                    end if
                end for
            end if
            
            if match_length > 0 then
                if i + match_length < n then
                    next_char = text[i + match_length]
                else
                    next_char = ""
                end if
                table.push([match_distance, match_length, next_char])
                i = i + match_length + 1
            else
                table.push([0, 0, text[i]])
                i = i + 1
            end if
        end while
        result = []
        for tuple in table
            result.push(char(tuple[0].toBin.zfill(12)[:10].to_int) + char(("0b" + tuple[0].toBin.zfill(12)[10:] + tuple[1].toBin.zfill(4)[2:]).to_int))
            result.push(tuple[2])
        end for
        return result.join("")
    end function

    globals.decompressLZ77 = function(text)
        i = 0
        result = ""
        bytes = "0b"
        for j in range(0, text.len, 3)
            if text.len - j == 2 then
                bytes = bytes + text[j].code.toBin[2:].zfill(8) + text[j + 1].code.toBin[2:].zfill(8)
            else if text.len - j == 0 then
            else
                bytes = bytes + text[j].code.toBin[2:].zfill(8) + text[j + 1].code.toBin[2:].zfill(8)
                for byte in text[j+2].encodeUtf8.bytes
                    bytes = bytes + byte[2:]
                end for
            end if
        end for
        bytes = bytes.bytes
        table = []

        while bytes.len > 0
            distance = (bytes[0] + bytes[1][2:-4]).to_int
            length = ("0b" + bytes[1][-4:]).to_int
            bytes = bytes[2:]
            if bytes.len == 0 then
                character = ""
            else if bytes[0].startsWith("0b0") then // 1-byte character
                character = char(bytes.pull.to_int)
            else if bytes[0].startsWith("0b110") then // 2-byte character
                character = (bytes.pull.toHex + bytes.pull.toHex).decodeUtf8
            else if bytes[0].startsWith("0b1110") then // 3-byte character
                character = (bytes.pull.toHex + bytes.pull.toHex + bytes.pull.toHex).decodeUtf8
            else if bytes[0].startsWith("0b11110") then // 4-byte character
                logger.error("decompressLZ77", "FormatError: The input bytes '" + [bytes.pull,bytes.pull,bytes.pull,bytes.pull].join(" ") + "' (UTF-8: " + [bytes.pull.toHex,bytes.pull.toHex,bytes.pull.toHex,bytes.pull.toHex].join("") + ") is currently not supported by Greyscript.")
                //character = (bytes.pull.toHex + bytes.pull.toHex + bytes.pull.toHex + bytes.pull.toHex).decodeUtf8
                character = ""
            else
                logger.error("decompressLZ77", "FormatError: The input byte '" + bytes.pull + "' is out of range.")
                character = ""
            end if
            table.push([distance,length,character])
        end while
        for tuple in table
            if tuple[1] == 0 then
                result = result + tuple[2]
            else
                distance = tuple[0]
                length = tuple[1]
                if distance != length then
                    result = result + result[-1 * distance: -1 * distance + length] + tuple[2]
                else
                    result = result + result[-1 * distance:] + tuple[2]
                end if
            end if
        end for

        return result
    end function

    globals.max = function(a,b)
        if a > b then return a
        return b
    end function

    globals.min = function(a,b)
        if a < b then return a
        return b
    end function

    // Determines the execution context of the script.
    // @description **Description:**
    // @description - This function checks if the script is being run as the main program or as an imported module.
    // @description - If the script's `program_path` is the same as `launch_path`, it indicates the script is executed as the main program and returns `"__main__"`.
    // @description - If the script is being run from a different script using `launch()`, it extracts and returns the script name from the `launch_path`.
    //
    // @description **Parameters:**
    // @description None.
    //
    // @description **Returns:**
    // @return {string}
    // @description `string` Returns `"__main__"` if the script is the main program, otherwise returns the script name extracted from `launch_path`.
    //
    // @example when script run directly: print __name__ // prints "__main__"
    // @example when script imported:     print __name__ // prints the script name, e.g., "module_name"
    globals.__name__ = function
        if program_path == launch_path then return "__main__"
        return launch_path.split("/")[-1]
    end function

    // Variables
    globals.initVars = function
        globals.logger.state = "normal" // accepts "normal", "debug" and "trace"

        get_shell.host_computer.touch(launch_path.split("/")[:-1].join("/"), launch_path.split("/")[-1] + ".log")
        globals.logger.file = get_shell.host_computer.File(launch_path + ".log")
        globals.logger.file.set_content("Started new log on " + current_date)

        globals.colorMap = {
            "red": "#FF0000",
            "maroon": "#800000",
            "brown": "#856256",
            "tomato": "#FF5533",
            "chocolate": "#D2691E",
            "orange": "#FFAA00",
            "gold": "#C3A200",
            "yellow": "#FFFF00",
            "light green": "#90EE90",
            "olive": "#808000",
            "green": "#008000",
            "alien": "#55DD00",
            "lime": "#00FF00",
            "cyan": "#00FFFF",
            "turquoise": "#40E0D0",
            "teal": "#008080",
            "light blue": "#ADD8E6",
            "deep sky blue": "#55AAFF",
            "blue": "#0000FF",
            "slate blue": "#6A5ACD",
            "navy": "#000080",
            "midnight blue": "#191970",
            "indigo": "#4B0082",
            "purple": "#800080",
            "magenta": "#FF00FF",
            "violet": "#EE82EE",
            "orchid": "#DD99CC",
            "salmon": "#FA8072",
            "pink": "#FFC0CB",
            "black": "#000000",
            "gray": "#808080",
            "silver": "#A8ABAE",
            "white": "#FFFFFF",
        }
    end function
    globals.GSP = true
	globals.initVars
	globals.remove("initVars")
end function
if not globals.hasIndex("GSP") then __scope
globals.remove("__scope")

//clear_screen

min = 33
max = 64
text = ""
for i in range(64)
    text = text + char(floor(rnd * max))
end for

string.encodeUtf16 = function
    text = self
    result = ""
    for character in text
        result = result + character.code.toHex
    end for
    return result
end function

print range(max(0, 1 - 4095), 1)
print compressLZ77("ababa")